# Chapter 04 CPU의 작동 원리

### 04-1 ALU와 제어장치

###### ALU

![3-1](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-1.jpg)

**ALU**는 레지스터를 통해 **피연산자**를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어 신호**를 받아들입니다. 

ALU가 내보내는 정보 : 연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있습니다. 그리고 이 결괏값은 바로 메모리에 저장되지 않고 일기적으로 레지스터에 저장됩니다. 또한 ALU는 계산결과와 더불어 플래그를 내보냅니다. **플래그**는 연산 결과에 대한 추가적인 상태 정보를 나타냅니다.

![3-2](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-2.jpg)

|    플래그 종류     |                             의미                             |                          사용 예시                           |
| :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    부호 플래그     |                연산한 결과의 부호를 나타낸다.                | 부호 플래그가 1일 경우 계산 결과는 음수, 0일 경우 계산 결과는 양수를 의미한다. |
|    제로 플래그     |              연산 결과가 0인지 여부를 나타낸다.              | 제로 플래그가 1일 경우 연산 괄겨는 0,0 일 경우 연산 결과는 0이 아님을 의미한다. |
|    캐리 플래그     |     연산 결과 올림수나 빌림수가 발생했는 지를 나타낸다.      | 캐리 플래그가 1일 경우 올림수나 빌림수가 발생했음을, 의미하고 0일 경우 발생하지 않았음을 의미한다. |
| 오버플로우 플래그  |             오버플로우가 발생했는지를 나타낸다.              | 오버플로우 플래그가 1일 경우 오버플로우가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 나타낸다. |
| 인터럽트    플래그 |               인터럽트가 가능한지를 나타낸다.                | 인터럽트 플래그가 1일 경우 인터럽트가 가능함을 의미하고, 0일 경우 인터럽트가 불가능함을 의미한다. |
| 슈퍼바이저 플래그  | 커널 모드가 실행 중인지, 사용자 모드로 실행중인지를 나타낸다. | 슈퍼바이저 플래그가 1일 경우 커널 모드로 실행 중임을 의미하고, 0일 경우 사용자 모드로 실행 중임을 의미한다. |

###### 제어장치

![3-3](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-3.jpg)

**제어장치**는 제어 신로를 내보내고, 명령어를 해석하는 부품이다. **제어 신호**는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.

**제어 장치가 받아들이는 정보**

- 제어장치는 클럭 신호를 받아들인다. 

 **클럭(Clock)**이란 컴퓨터의 모든 부품을 일시불란하게 움직일 수 있게 하는 시간 단위이다. 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들이는 것이다.

- 제어장치는 '해석해야 할 명령어'를 받아들인다.

CPU가 해석해야 할 명령어는 **명령어 레지스터**라는 특별한 레지스터에 저장된다. 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.

- 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다.

플래그는 ALU 연산에 대한 추가적인 상태 정보라 했다. 제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킵니다

- 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들인다.

제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 한다.

### 04-2 레지스터

###### 반드시 알아야 할 레지스터

1. **프로그램 카운터** : 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장합니다. 프로그램 카운터를 **명령어 포인터**라고 부르는 CPU도 있다.
2. **명령어 레지스터 **: 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.
3. **메모리 주소 레지스터** : 메모리의 주소를 저장하는 레지스터이다. CPU가 읽어 들이고자 하는 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됩니다.
4. **메모리 버퍼 레지스터** : 메모리와 주고받을 값 (데이터와 명령어)을 저장하는 레지스터이다. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다. CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고받을 밗은 메모리 버퍼 레지스터를 거친다.
5. **플래그 레지스터 **: ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장한다.
6. **범용 레지스터** : 이름 그대로 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터입니다. 메모리 버퍼 레지스터는 데이터 버스로 주고받을 값만 저장하고, 메모리 주소 레지스터는 주소 버스로 내보낼 주소값만 저장하지만, 범용 레지스터는 데이터와 주소를 모두 저장할 수 있다. 
7. **스택 포인터**
8. **베이스 레지스터**

***메모리에 저장된 프로그램을 실행하는 과정***

1. CPU로 실행할 프로그램이 1000번지부터 1500번지까지 저장되어 있다고 가정한다. 그리고 1000번지에는 1101이 저장되어 있다고 가정한다.



![3-4](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-4.jpg)

2. 프로그램을 처음부터 실행사기 위해프로그램 카운터에는 1000이 저장된다. 이는 메모리에서 가져올 명령어가 1000번지에 있다는 걸 의미한다.

![3-5](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-5.jpg)

3. 1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 내보내야 한다. 이를 위해 메모리 주소 레지스터에는 1000이 저장된다.

![3-13](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-13.jpg)

4. '메모리 읽기' 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내진다.

![3-6](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-6.jpg)

5. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 합니다.

![3-7](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-7.jpg)

6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동합니다.

![3-8](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-8.jpg)

7. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킵니다.

   ![3-9](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-9.jpg)

이처럼 프로그램 카운터는 지속적으로 증가하며 계쏙해서 다음 명령어를 읽어 들일 준비를 합니다. 이 과정이 반복되면서 CPU는 프로그램을 차례대로 실행해 나갑니다. 결국 CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문입니다.

### 특정 레지스터를 이용한 주소 지정 방식(1) : 스택 주소 지정 방식

![3-10](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-10.jpg)

**스택 주소 지정 방식**은 스택과 스택 포인터를 이용한 주소 지정 방식이다.

**스택 포인터**란 스택의 꼭대기를 가리키는 레지스터이다. 즉 스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터이다.

**스택 영역** : 스택은 메모리 안에 있다. 정확히는 메모리 안에 스택처럼 사용할 영역이 정해져 있다.

### 특정 레지스터를 이용한 주소 지정 방식(2) : 변위 주소 지정 방식

**변위 주소 지정 방식**이란 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다.

이때, 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 덩하는지에 따라 **상대 주소 지정 방식**, **베이스 레지스터 주소 지정 방식**등으로 나뉩니다.

###### 상대 주소 지정 방식

![3-11](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-11.jpg)

**상대 주소 지정 방식**은 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다. 프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있다. 만약 오퍼랜드가 음수 -3 이라면 CPU는 읽어 들이기로 한 명령어로부터 '세 번째 이전'번지로 접근합니다. 한마디로 실행하려는 명령어의 세 칸 이전 번지 명령어를 실행하는 것이다. 상대 주소 지정 방식은 프로그래밍 언어의 IF문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용된다.

###### 베이스 레지스터 주소 지정 방식

![3-12](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-12.jpg)

**베이스 레지스터 주소 지정 방식**은 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식이다. 여기서 베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할을 한다. 즉 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근 할 것인지를 연산하여 유효 주소를 얻는 방법이다.

### 04-3명령어 사이클과 인터럽트

![3-14](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-14.jpg)

**명령어 사이클** : 실행하는 프로그램은 수 많은 명령어로 이루어져 있고, CPU는 이 명령어들을 하나씩 실행한다. 이때 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행된다. 이때 주기가 명령어 사이클이다.

![3-15](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-15.jpg)

**인출 사이클** : 메모리에 있는 명령어를 CPU로 가지고 오는 단계

**실행 사이클** : CPU로 가져온 명령어를 실행하는 단계

**간접 사이클** : 간접 주소 지정 방식과 같은 명령어를 실행하기 위해서 메모리 접근을 한 번 더하는 단계

### 인터럽트

![3-16](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\3-16.jpg)

**인터럽트** : CPU가 수행 중인 작업은 방해 받아 잠시 중단될 수 있다. 이렇게 CPU의 작업을 방해하는 신호를 의미한다.

**동기 인터럽트(예외)** : CPU에 의해 발생하는 인터럽트로 CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때, 가령 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트

**비동기 인터럽트(하드웨어 인터럽트)** : 주로 입출력장치에 의해 발생하는 인터럽트이다. 

- CPU가 프린터와 같은 입출력장치에 입출력 작업을 부탁하면 작업이 끝난 입출력장치가 CPU에 완료 알림(인터럽트)를 보낸다.
- 키보드, 마우스와 같은 입출력장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)를 보낸다.

**하드웨어 인터럽트** : 알림과 같은 인터럽트 이다. 하드웨어 인터럽트를 이용하면 CPU는 주기적으로 프린트 완료 여부를 확인할 필요가 없다. CPU는 프린터로부터 프린트 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다.

***하드웨어 인터럽트 처리 순서**

1. 입출력장치는 CPU에 **인터럽트 요청신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다.



**인터럽트 요청신호** : 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기 때문에 다른 누군가가 인터럽트하기 전에는 CPU에 물어봐야하는데 이러한 신호를 인터럽트 요청 신호라고 한다.

**인터럽트 플래그** : 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그

**인터럽트 서비스 루틴** : 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다. 요컨대 'CPU가 인터럽트를 처리한다.'는 말은 '인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 되돌아온다.'라는 말과 같다

**수행 순서**

1. 정상적으로 작업 진행
2. 인터럽트 발생
3. 인터럽트 서비스 루틴으로 점프
4. 인터럽트 서비스 루틴 실행
5. 기존 작업으로 점프
6. 기존 작업 수행 재개



**인터럽트 벡터** : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보

***CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업한다.**



###### 동기 인터럽트(예외)의 종류

예외가 발생하면  CPU는 하던 일을 중단하고 해당 예외를 처리한다.

- **폴트(fault)** : 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
- **트랩(trap)** : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
- **중단** : CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
- **소프트웨어 인터럽트** : 시스템 호출이 발생했을 때 나타난다.
