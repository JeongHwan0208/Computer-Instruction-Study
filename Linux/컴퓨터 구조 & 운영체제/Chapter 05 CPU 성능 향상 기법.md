# Chapter 05 CPU 성능 향상 기법

### 05 -1 빠른 CPU를 위한 설계 기법

**클럭**

클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 것이고, 다른 부품들도 그에 발맞춰 더 빠르게 작동할 것이다.

**클럭 속도**는 헤르츠(Hz) 단위로 측정한다. 이는 1초에 클럭이 몇 번 반복되는지를 나타낸다.

**코어와 멀티코어**

![4-1](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\4-1.jpg)

**코어** : 명령어를 실해하는 부품

오늘날의 CPU는 '명령어를 실행하는 부품을 여러 개 포함하는 부품'으로 명칭의 범위가 확장되었다.

**멀티코어 CPU 또는 멀티코어 프로세서** : 코어를 여러개 포함하고 있는 CPU

| 코어 수 |      프로세서 명칭      |
| :-----: | :---------------------: |
|    1    |  싱글코어(single-core)  |
|    2    |   듀얼코어(dual-core)   |
|    3    | 트리플코어(triple-core) |
|    4    |   쿼드코어(quad-core)   |
|    6    |   헥사코어(hexa-core)   |
|    8    |   옥타코어(octa-core)   |
|   10    |   데카코어(deca-core)   |
|   12    | 도데카코어(dodeca-core) |

 **스레드와 멀티스레드**

**스레드**  

- **하드웨어적 스레드**
- **소프트웨어적 스레드**

***하드웨어적 스레드***

하나의 코어가 동시에 처리하는 명령어 단위

![4-2](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\4-2.jpg)

2코어 4스레드 CPU는 그림처럼 명령어를 실행하는 부품을 두 개 포함하고, 한 번에 네 개의 명령어를 처리할 수 있는 CPU를 의미한다.

이처럼 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 **멀티 스레드 프로세서** 또는 **멀티스레드 CPU**라고 한다.

***소프트웨어적 스레드***

하나의 프로그램에서 독립적으로 실행되는 단위

![4-3](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\4-3.jpg)

하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있다.

위 그림처럼 여러 기능들을 작동시키는 코드를 각각의 스레드로 만들면 동시에 실행할 수 있다.

***멀티스레드 프로세서***

멀티스레드 프로세서를 실제로 설계하는 일은 매우 복잡하지만, 가장 큰 핵심은 레지스터이다.

![4-4](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\4-4.jpg)

하나의 명령어를 실행하기 위해 꼭 필요한 레지스터들을 편의상 '레지스터 세트'라고 표기하고, 레지스터 세트가 한 개인 CPU는 한 개의 명령어를 처리하기 위한 정보들을 기억할 뿐이지만, 레지스터 세트가 두개인 CPU는 두 개의 명령어를 처리하기 위한 정보들을 기억할 수 있다. 여기서 ALU와 제어장치가 두 개의 레지스터 세트에 저장된 명령어를 해석하고 실행하면 하나의 코어에서 두 개의 명령어가 동시에 실행된다.

***메모리 속 프로그램 입장에서 봤을 때 하드웨어 스레드는 마치 '한 번에 하나의 명령어를 처리하는 CPU'나 다름 없다. 프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 여러 개 있는 것 처럼 보인다. 그래서 하드웨어 스레드를 논리 프로세서라고 부르기도 한다.**

![4-5](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\4-5.jpg)

### 05-2 명령어 병렬 처리 기법

- **명령어 파이프라이닝**
- **슈퍼스칼라**
- **비순차적 명령어 처리**



***명령어 파이프라이닝***

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장

![4-6](C:\Users\pc\Desktop\HIPS\Linux\컴퓨터 구조 & 운영체제\컴퓨터 구조 & 운영체제 image\4-6.jpg)

이처럼 마치 공장 생산 라인과 같이 명령어들을 **명령어 파이프라인**에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝**이라고 한다.

**파이프라인 위험**

- **데이터 위험**
- **제어 위험**
- **구조적 위험**



**데이터 위험**

명령어 간 '데이터 의존성'에 의해 발생한다. 모든 명령어를 동시에 처리할 수는 없다. 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 있다.

```c
명령어 1 : R1 <- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장
명령어 2 : R4 <- R1 + R5 // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장
```

위에 경우 명령어 1을 수행해야만 명령어 2를 수행할 수 있다. 이처럼 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 '데이터 위험'이라 한다.

**제어 위험**

주로 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생한다. 기본적으로 프로그램 카운터는 '현재 실행 중인 명령어의 다음 주소'로 갱신된다. 하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리중이었던 명령어들은 아무 쓸모가 없어진다. 이를 '제어 위험'이라 한다. 참고로 이를 위해 사용되는 기술 중 하나가 **분기 예측**이다. 

**구조적 위험**

명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생한다. 구조적 위험은 **자원 위험**라고도 부른다.



**슈퍼스칼라**

CPU 내부에 여러 개의 명령어 파이프 라인을 포하뫈 구조를 슈퍼스칼라라고 한다.



***비순차적 명령어 처리(OoOE)***

명령어들을 순차적으로 실행하지 않는 기법, 명령어의 '합법적인 새치시'

```
1 M(100) <- 1
2 M(101) <- 2
3 M(102) <- M(100) + M(101)
4 M(150) <- 1
5 M(151) <- 2
6 M(152) <- 3
```

3번 명령어를 실행하기 위해서는 1번과 2번 명령어 실행이 끝날때 까지 기다려야 한다는 점이다.

그래서 3번은 명령어의 순서를 바꾸어 실행해도 크게 문제될 것이 없다.

```
1 M(100) <- 1
2 M(101) <- 2
4 M(150) <- 1
5 M(151) <- 2
6 M(152) <- 3
3 M(102) <- M(100) + M(101)
```

이렇게 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 **비순차적 명령어 처리 기법**이라 한다.

### 05-3 CISC와 RISC

**명령어 집합** or **명령어 집합 구조(ISA)**

CPU가 이해할 수 있는 명령어들의 모음



| CISC(Complex Instruction Set Computer) | RISC(Reduce Instruction Set Computer) |
| :------------------------------------: | :-----------------------------------: |
|         복잡하고 다양한 명령어         |         단순하고 적은 명령어          |
|            가변 길이 명령어            |           고정 길이 명령어            |
|         다양한 주소 지정 방식          |          적은 주소 지정 방식          |
|  프로그램을 이루는 명령어의 수가 적음  | 프로그램을 이루는 명령어의 수가 많음  |
|      여러 클럭에 걸쳐 명령어 수행      |       1클럭 내외로 명령어 수행        |
|        파이프라이닝하기 어려움         |        파이프라이닝 하기 쉬움         |

